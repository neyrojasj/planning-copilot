# Setup Rust Web App - Initialize Project

Execute this prompt to create a new Rust web application with the recommended production-ready stack.

## ğŸ“¥ Input Required

Before starting, the user MUST provide:

| Input | Description | Example |
|-------|-------------|---------|
| **Project Name** | The name of the project (snake_case) | `my_api` |
| **Description** | Brief description of what the app does | `REST API for user management` |

---

## ğŸ¦€ Recommended Stack

This prompt sets up the following production-ready Rust web stack:

| Component | Technology | Version | Purpose |
|-----------|------------|---------|---------|
| **Web Framework** | Axum | latest | High-performance, ergonomic web framework |
| **Async Runtime** | Tokio | 1.x | Industry-standard async runtime |
| **Database** | PostgreSQL | 15+ | Robust relational database |
| **Query Library** | SQLx | 0.8.x | Compile-time verified SQL queries |
| **Serialization** | Serde + serde_json | 1.x | JSON serialization/deserialization |
| **Error Handling** | thiserror + anyhow | latest | Ergonomic error handling |
| **Logging** | tracing + tracing-subscriber | latest | Structured async-aware logging |
| **Configuration** | dotenvy | latest | Environment variable loading |
| **Validation** | validator | latest | Request validation |

---

## ğŸ“‹ Instructions

Perform ALL of the following steps in order. Do not skip any steps.

---

## Step 1: Initialize Cargo Project

```bash
cargo new [PROJECT_NAME] --name [PROJECT_NAME]
cd [PROJECT_NAME]
```

---

## Step 2: Create Project Structure

Create the following directory structure:

```
[PROJECT_NAME]/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Makefile
â”œâ”€â”€ README.md
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ migrations/
â”‚   â””â”€â”€ .gitkeep
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ config.rs
â”‚   â”œâ”€â”€ error.rs
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ health.rs
â”‚   â”œâ”€â”€ handlers/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ health.rs
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ db/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ pool.rs
â”‚   â””â”€â”€ middleware/
â”‚       â””â”€â”€ mod.rs
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ integration/
â”‚       â”œâ”€â”€ mod.rs
â”‚       â””â”€â”€ health_test.rs
â””â”€â”€ .copilot/
    â””â”€â”€ docs/
        â””â”€â”€ (generated by Smart Agent)
```

---

## Step 3: Create Cargo.toml

```toml
[package]
name = "[PROJECT_NAME]"
version = "0.1.0"
edition = "2021"
authors = ["[AUTHOR_NAME]"]
description = "[DESCRIPTION]"
license = "MIT"
readme = "README.md"

[dependencies]
# Web Framework
axum = { version = "0.7", features = ["macros"] }
tokio = { version = "1", features = ["full"] }
tower = "0.5"
tower-http = { version = "0.6", features = ["cors", "trace", "timeout"] }

# Database
sqlx = { version = "0.8", features = ["runtime-tokio", "postgres", "uuid", "chrono"] }

# Serialization
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# Error Handling
thiserror = "2"
anyhow = "1"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }

# Configuration
dotenvy = "0.15"

# Validation
validator = { version = "0.18", features = ["derive"] }

# Utilities
uuid = { version = "1", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }

[dev-dependencies]
tokio-test = "0.4"
reqwest = { version = "0.12", features = ["json"] }

[profile.release]
lto = true
codegen-units = 1
panic = "abort"
strip = true
```

---

## Step 4: Create Core Files

### 4.1 src/main.rs

```rust
use [PROJECT_NAME]::run;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    run().await
}
```

### 4.2 src/lib.rs

```rust
pub mod config;
pub mod db;
pub mod error;
pub mod handlers;
pub mod middleware;
pub mod models;
pub mod routes;

use axum::Router;
use std::net::SocketAddr;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

pub async fn run() -> anyhow::Result<()> {
    // Initialize tracing
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| "info".into()))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // Load configuration
    let config = config::Config::from_env()?;
    
    // Initialize database pool
    let pool = db::pool::create_pool(&config.database_url).await?;

    // Build application
    let app = Router::new()
        .merge(routes::routes(pool))
        .layer(TraceLayer::new_for_http());

    // Start server
    let addr: SocketAddr = format!("{}:{}", config.host, config.port).parse()?;
    tracing::info!("ğŸš€ Server listening on {}", addr);

    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app).await?;

    Ok(())
}
```

### 4.3 src/config.rs

```rust
use anyhow::Context;

#[derive(Debug, Clone)]
pub struct Config {
    pub host: String,
    pub port: u16,
    pub database_url: String,
    pub rust_log: String,
}

impl Config {
    pub fn from_env() -> anyhow::Result<Self> {
        dotenvy::dotenv().ok();

        Ok(Self {
            host: std::env::var("HOST")
                .context("HOST environment variable must be set")?,
            port: std::env::var("PORT")
                .context("PORT environment variable must be set")?
                .parse()
                .context("PORT must be a valid number")?,
            database_url: std::env::var("DATABASE_URL")
                .context("DATABASE_URL environment variable must be set")?,
            rust_log: std::env::var("RUST_LOG")
                .context("RUST_LOG environment variable must be set")?,
        })
    }
}
```

### 4.4 src/error.rs

```rust
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Resource not found: {0}")]
    NotFound(String),

    #[error("Bad request: {0}")]
    BadRequest(String),

    #[error("Internal server error: {0}")]
    Internal(String),

    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),

    #[error("Validation error: {0}")]
    Validation(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, message) = match &self {
            AppError::NotFound(msg) => (StatusCode::NOT_FOUND, msg.clone()),
            AppError::BadRequest(msg) => (StatusCode::BAD_REQUEST, msg.clone()),
            AppError::Validation(msg) => (StatusCode::UNPROCESSABLE_ENTITY, msg.clone()),
            AppError::Internal(msg) => {
                tracing::error!("Internal error: {}", msg);
                (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error".to_string())
            }
            AppError::Database(e) => {
                tracing::error!("Database error: {}", e);
                (StatusCode::INTERNAL_SERVER_ERROR, "Database error".to_string())
            }
        };

        let body = Json(json!({
            "error": message,
            "status": status.as_u16()
        }));

        (status, body).into_response()
    }
}

pub type AppResult<T> = Result<T, AppError>;
```

### 4.5 src/routes/mod.rs

```rust
pub mod health;

use axum::Router;
use sqlx::PgPool;

pub fn routes(pool: PgPool) -> Router {
    Router::new()
        .merge(health::routes())
        .with_state(pool)
}
```

### 4.6 src/routes/health.rs

```rust
use axum::{routing::get, Router};
use crate::handlers;

pub fn routes() -> Router<sqlx::PgPool> {
    Router::new()
        .route("/health", get(handlers::health::health_check))
        .route("/health/ready", get(handlers::health::readiness_check))
}
```

### 4.7 src/handlers/mod.rs

```rust
pub mod health;
```

### 4.8 src/handlers/health.rs

```rust
use axum::{extract::State, http::StatusCode, Json};
use serde_json::{json, Value};
use sqlx::PgPool;

pub async fn health_check() -> Json<Value> {
    Json(json!({
        "status": "healthy",
        "version": env!("CARGO_PKG_VERSION")
    }))
}

pub async fn readiness_check(
    State(pool): State<PgPool>,
) -> Result<Json<Value>, StatusCode> {
    sqlx::query("SELECT 1")
        .fetch_one(&pool)
        .await
        .map_err(|_| StatusCode::SERVICE_UNAVAILABLE)?;

    Ok(Json(json!({
        "status": "ready",
        "database": "connected"
    })))
}
```

### 4.9 src/db/mod.rs

```rust
pub mod pool;
```

### 4.10 src/db/pool.rs

```rust
use anyhow::Context;
use sqlx::{postgres::PgPoolOptions, PgPool};

pub async fn create_pool(database_url: &str) -> anyhow::Result<PgPool> {
    PgPoolOptions::new()
        .max_connections(10)
        .connect(database_url)
        .await
        .context("Failed to connect to database")
}
```

### 4.11 src/models/mod.rs

```rust
// Add your data models here
```

### 4.12 src/middleware/mod.rs

```rust
// Add custom middleware here
```

---

## Step 5: Create .env.example

```env
# Server Configuration
HOST=127.0.0.1
PORT=3000

# Database Configuration
DATABASE_URL=postgres://postgres:password@localhost:5432/[PROJECT_NAME]

# Logging
RUST_LOG=info,[PROJECT_NAME]=debug
```

---

## Step 6: Create Makefile

```makefile
.PHONY: help build run dev test check lint fmt clean docker-up docker-down migrate

# Colors for output
CYAN := \033[36m
GREEN := \033[32m
YELLOW := \033[33m
RESET := \033[0m

# Project configuration
PROJECT_NAME := [PROJECT_NAME]
DOCKER_COMPOSE := docker compose

help: ## Show this help message
	@echo "$(CYAN)$(PROJECT_NAME) - Makefile Commands$(RESET)"
	@echo ""
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "  $(GREEN)%-15s$(RESET) %s\n", $$1, $$2}'

# ============================================================================
# Development
# ============================================================================

build: ## Build the project in release mode
	@echo "$(CYAN)Building $(PROJECT_NAME)...$(RESET)"
	cargo build --release

run: ## Run the application
	@echo "$(CYAN)Running $(PROJECT_NAME)...$(RESET)"
	cargo run

dev: ## Run with hot-reload (requires cargo-watch)
	@echo "$(CYAN)Starting development server with hot-reload...$(RESET)"
	cargo watch -x run

# ============================================================================
# Testing
# ============================================================================

test: ## Run all tests
	@echo "$(CYAN)Running tests...$(RESET)"
	cargo test

test-verbose: ## Run tests with verbose output
	cargo test -- --nocapture

test-coverage: ## Run tests with coverage (requires cargo-tarpaulin)
	cargo tarpaulin --out Html

# ============================================================================
# Code Quality
# ============================================================================

check: ## Run cargo check
	@echo "$(CYAN)Running cargo check...$(RESET)"
	cargo check

lint: ## Run clippy lints
	@echo "$(CYAN)Running clippy...$(RESET)"
	cargo clippy -- -D warnings

fmt: ## Format code
	@echo "$(CYAN)Formatting code...$(RESET)"
	cargo fmt

fmt-check: ## Check code formatting
	cargo fmt -- --check

audit: ## Audit dependencies for security vulnerabilities
	cargo audit

# ============================================================================
# Database
# ============================================================================

migrate: ## Run database migrations
	@echo "$(CYAN)Running migrations...$(RESET)"
	sqlx migrate run

migrate-create: ## Create a new migration (usage: make migrate-create NAME=migration_name)
	sqlx migrate add $(NAME)

migrate-revert: ## Revert last migration
	sqlx migrate revert

db-reset: docker-down docker-up ## Reset database (down + up)
	@sleep 2
	@echo "$(CYAN)Database reset complete$(RESET)"

# ============================================================================
# Docker
# ============================================================================

docker-up: ## Start Docker services (PostgreSQL)
	@echo "$(CYAN)Starting Docker services...$(RESET)"
	$(DOCKER_COMPOSE) up -d

docker-down: ## Stop Docker services
	@echo "$(CYAN)Stopping Docker services...$(RESET)"
	$(DOCKER_COMPOSE) down

docker-logs: ## Show Docker logs
	$(DOCKER_COMPOSE) logs -f

# ============================================================================
# Utilities
# ============================================================================

clean: ## Clean build artifacts
	@echo "$(CYAN)Cleaning build artifacts...$(RESET)"
	cargo clean

install-tools: ## Install required development tools
	@echo "$(CYAN)Installing development tools...$(RESET)"
	cargo install cargo-watch cargo-tarpaulin cargo-audit sqlx-cli

setup: install-tools docker-up ## Initial project setup
	@echo "$(GREEN)Setup complete! Run 'make dev' to start developing.$(RESET)"
```

---

## Step 7: Create docker-compose.yml

```yaml
services:
  postgres:
    image: postgres:15-alpine
    container_name: [PROJECT_NAME]_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: [PROJECT_NAME]
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
```

---

## Step 8: Create .gitignore

```gitignore
# Generated by Cargo
/target/

# Environment files
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# macOS
.DS_Store

# Logs
*.log

# Coverage
tarpaulin-report.html
coverage/
```

---

## Step 9: Create README.md

```markdown
# [PROJECT_NAME]

> [DESCRIPTION]

## ğŸ¦€ Tech Stack

| Component | Technology |
|-----------|------------|
| Framework | Axum |
| Runtime | Tokio |
| Database | PostgreSQL |
| Query Library | SQLx |

## ğŸš€ Quick Start

### Prerequisites

- Rust 1.75+ (install via [rustup](https://rustup.rs/))
- Docker & Docker Compose (for PostgreSQL)
- make

### Setup

```bash
# Clone the repository
git clone [REPO_URL]
cd [PROJECT_NAME]

# Install development tools
make install-tools

# Start PostgreSQL
make docker-up

# Copy environment variables
cp .env.example .env

# Run migrations
make migrate

# Start development server
make dev
```

## ğŸ“š Available Commands

Run `make help` to see all available commands:

| Command | Description |
|---------|-------------|
| `make dev` | Start development server with hot-reload |
| `make build` | Build for production |
| `make test` | Run all tests |
| `make lint` | Run clippy lints |
| `make fmt` | Format code |
| `make migrate` | Run database migrations |
| `make docker-up` | Start PostgreSQL |
| `make docker-down` | Stop PostgreSQL |

## ğŸ”— API Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/health` | Health check |
| GET | `/health/ready` | Readiness check (with DB) |

## ğŸ“ Project Structure

```
[PROJECT_NAME]/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs         # Entry point
â”‚   â”œâ”€â”€ lib.rs          # Library root
â”‚   â”œâ”€â”€ config.rs       # Configuration
â”‚   â”œâ”€â”€ error.rs        # Error handling
â”‚   â”œâ”€â”€ routes/         # Route definitions
â”‚   â”œâ”€â”€ handlers/       # Request handlers
â”‚   â”œâ”€â”€ models/         # Data models
â”‚   â”œâ”€â”€ db/             # Database layer
â”‚   â””â”€â”€ middleware/     # Custom middleware
â”œâ”€â”€ migrations/         # SQL migrations
â”œâ”€â”€ tests/              # Integration tests
â”œâ”€â”€ Makefile            # Build commands
â””â”€â”€ docker-compose.yml  # Docker services
```

## ğŸ“„ License

MIT
```

---

## Step 10: Apply Rust Standards

Read and apply coding standards from `.copilot/standards/rust.md`:

- Use `thiserror` for library errors (already in error.rs)
- Use `anyhow` for application errors (already configured)
- Never use `.unwrap()` without justification - use `.context()` instead
- No default values for environment variables - fail fast
- All public items must be documented

---

## Step 11: Initialize Agent Memory

After creating the project structure, run the **Setup Project** handoff to initialize `.copilot/docs/` documentation.

---

## Step 12: Report Summary

After completing all steps, provide a summary:

```
âœ… **Rust Web App Initialized**

**Project**: [PROJECT_NAME]
**Stack**: Axum + SQLx + PostgreSQL

**Files Created:**
- Cargo.toml (dependencies configured)
- Makefile (development commands)
- docker-compose.yml (PostgreSQL)
- README.md (comprehensive documentation)
- src/ (application code)
- .env.example (environment template)

**Next Steps:**
1. Run `cp .env.example .env` and configure
2. Run `make docker-up` to start PostgreSQL
3. Run `make migrate` to run migrations
4. Run `make dev` to start development server

**Available at:** http://localhost:3000/health
```

---

## âš ï¸ Important Notes

1. **Replace placeholders** - Replace all `[PROJECT_NAME]` and `[DESCRIPTION]` with actual values
2. **Apply standards** - Always follow `.copilot/standards/rust.md`
3. **No silent failures** - All errors must be handled explicitly
4. **Environment variables** - Never provide defaults, fail if missing
